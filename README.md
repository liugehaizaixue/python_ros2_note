# python_study  

## pub  
ros2 基础的pub节点  
发布消息（测试用）  

## ros2_sub_delay_exe  
[ros2_sub_delay_exe](./ros2_sub_delay_exe.py)  
rclpy库和asyncio库在事件循环上有冲突，因此无法直接在ROS2的回调函数中使用asyncio.sleep()  
在ROS2中，多个监听者（Subscribers）的回调函数是按照事件顺序同步执行的。也就是说，每当有消息到达时，ROS会按照创建监听者的顺序依次调用它们的回调函数。  
当一个监听者的回调函数被调用时，其它监听者的回调函数将会等待，直到当前回调函数执行完成。这种同步执行方式可以确保消息处理的顺序性，并避免竞争条件和数据冲突。  

如果需要在不同线程中并行处理消息，可以考虑使用`多线程`或`异步编程`模型，在每个线程或任务中创建独立的监听者，并执行相应的回调函数。  

此时如果想实现以下效果  
`callback1 在执行过程中使用callback2获取的当前（较新的）数据时，可以延迟执行callback1中的部分内容。`

而此处使用ros2的`定时器`方法，实现`延迟执行`  
```python
timer = self.create_timer(1.0, self.delayed_action)
```
create_timer() 是Node类的一个方法，用于创建一个定时器。  
当定时器被创建后，它会以指定的时间间隔周期性地触发，然后调用所设置的回调函数self.delayed_action。你可以在delayed_action() 方法中编写执行操作的代码，这些操作将在每次定时器触发时执行。  

使用定时器可以很方便地实现在指定的时间间隔后执行某些操作，而`不必阻塞主循环`。这对于处理需要按照特定时间间隔执行的任务非常有用，例如周期性地发布消息或执行传感器读取等操作。  

当回调函数callback()被调用时，它会执行一些操作（如打印消息）后，创建一个新的定时器self.timer。定时器将以1秒的时间间隔周期性地触发，并调用回调函数self.delayed_action。这个定时器是在每个回调函数中动态地创建的，所以每个回调函数都有自己独立的定时器实例。  

`一旦回调函数执行完毕，定时器就会被释放。`这是因为定时器的生命周期与回调函数的生命周期绑定在一起：它们是在同一个作用域内定义的并且没有被存储为类成员变量。一旦回调函数完成执行，定时器不再被引用，它的相关资源将被自动释放。  